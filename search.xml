<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F10%2F02%2Fhello-world2%2F</url>
    <content type="text"><![CDATA[哈哈哈哈哈 打我吧！！！！！！！！！！！！]]></content>
  </entry>
  <entry>
    <title><![CDATA[webssh]]></title>
    <url>%2F2018%2F10%2F08%2Fwebssh%2F</url>
    <content type="text"><![CDATA[Webssh webssh从而SSH无需Xshell之类的模拟终端工具进行SSH连接，将SSH这一比较低层的操作也从C/S架构扭转成为B/S架构 这样的架构常用在运维制作开发一些堡垒机等系统，或者目前比较新型的在线教育方式，通过WebSSH向学生提供一个可以直接使用浏览器进行相关Linux操作或代码编写的学习方式 WebSSh主要是建立客户端与服务端的即时通信 实现方案 彻底WebSSH实现方式，将通过结合WebSocket以及逐步的Paramiko来进行实现，所需要的技术栈如下 1234＃前端vue websocket xterm.js 12345＃首次django dwebsocket paramiko 线程 技术介绍 xterm 前端通过xterm插件进行shell黑窗口环境的构建，这个插件会自动解析由后台paramiko返回的带有标记样式的命令结果，并渲染到浏览器中，非常酷炫 websocket 这里通过websocket进行浏览器与django的数据交通同轴，Websocket是什么 paramiko paramiko此时的角色采取承担django与Linux环境的互动，将前端发来的命令发送给后台，将后端发来的命令结果返回到前端的xterm组件中 前端实现 前端xterm组件使用：简单 安装xterm 123npm install xterm --save 指定版本号 npm install xterm@版本号 --save 在vue-cli的package.json文件指明了vue-cli项目在 npm install 时候所安装的插件及插件的版本号xterm在4.1.0版本前是有 dist和lib等很多文件夹的，在4.1.0版后对xterm进行了整合，精简。 vue框架中引入xterm的样式文件 1234567891011121314151617// main.js// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from &apos;vue&apos;import App from &apos;./App&apos;import router from &apos;./router&apos;import &apos;xterm/dist/xterm.css&apos; // 看这里，添加xterm css文件样式Vue.config.productionTip = false/* eslint-disable no-new */new Vue(&#123;el: &apos;#app&apos;,router,components: &#123; App &#125;,template: &apos;&lt;App/&gt;&apos;&#125;) 初始化xterm组件并添加两个插件：attach可以将终端附加到websocket流中，fit可以调整终端的大小以及行和列适配父级元素 1234567// index.vueimport &#123; Terminal &#125; from &apos;xterm&apos;import * as attach from &apos;xterm/lib/addons/attach/attach&apos;import * as fit from &apos;xterm/lib/addons/fit/fit&apos;Terminal.applyAddon(attach)Terminal.applyAddon(fit) 构建websocket并绑定到终端，websocket地址为ws协议前缀，此时使用的是即将在django中配置Websocket后台视图的路由，这一系列行为将挂载到钩子函数下进行 12345678910111213141516171819mounted () &#123;let terminalContainer = document.getElementById(&apos;terminal&apos;)this.term = new Terminal(this.terminal)this.term.open(terminalContainer)// open websocketthis.terminalSocket = new WebSocket(&apos;ws://127.0.0.1:8000/webssh/&apos;)this.terminalSocket.onopen = function()&#123; console.log(&apos;websocket is Connected...&apos;)&#125;this.terminalSocket.onclose = function()&#123; console.log(&apos;websocket is Closed...&apos;)&#125;this.terminalSocket.onerror = function()&#123; console.log(&apos;damn Websocket is broken!&apos;)&#125;this.term.attach(this.terminalSocket)// 绑定xterm到ws流中&#125;, 当浏览器关闭时，也代表着客户端关闭，此时主动断开连接，交给vue的钩子函数来处理这个问题 1234beforeDestroy () &#123;this.terminalSocket.close()this.term.destroy()&#125; 后端实现 django这里使用dwebsocket模块进行ws的服务端编写与通信 首先确定路由，也是前端的ws连接地址 123#urls.py ...path(&apos;webssh/&apos;,webssh) 定义函数，初始化SSH连接对象 1234567#views.py def _ssh(host,username,password,port=22):sh = paramiko.SSHClient()sh.set_missing_host_key_policy(paramiko.AutoAddPolicy())sh.connect(host, username=username, password=password)channle = sh.invoke_shell(term=&apos;xterm&apos;)return channle 由于在SSH通道中，服务端可能返回结果的方式并不是与客户端发起的命令一唱一和，可能是一唱多和，比如类似top这样的命令，一次命令输入之后，服务端会返回N次结果，此时在django视图中采用多线程，专门处理命令结果的返回；以下是这个任务线程函数的定义 123456789101112def recv_ssh_msg(channle,ws):&apos;&apos;&apos; channle: 建立好的SSH连接通道 这个函数会不停的接收ssh通道返回的命令 返回到前端的ws套接字里&apos;&apos;&apos; while not channle.exit_status_ready(): try: buf = channle.recv(1024) # 接收命令的执行结果 ws.send(buf) # 向Websocket通道返回 except: break 剩余的就是视图函数的调用和线程开启部分了！ 1234567891011121314151617181920@accept_websocketdef webssh(request): &apos;&apos;&apos; 1: 接收前端(ws)的命令，发给后台(ssh) 2: 接收后台的返回结果，给到前端 &apos;&apos;&apos; if request.is_websocket: channle = _ssh(host, username=username, password=password) ws = request.websocket t = threading.Thread(target=recv_ssh_msg,args=(channle,ws)) t.setDaemon(True) t.start() # 线程开启 while 1: cmd = ws.wait() # 阻塞接收前端发来的命令 if cmd: channle.send(cmd) # 由SSH通道转交给Linux环境 else: # 连接断开 跳出循环 break ws.close() # 释放对应套接字资源 channle.close()]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO 搭建个人博客]]></title>
    <url>%2F2017%2F06%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Hexo 是一款基于 Node.js 的静态博客框架。Hexo 使用 Markdown 解析文章，用户在本地安装Hexo并进行写作，通过一条命令，Hexo即可利用靓丽的主题自动生成静态网页。 安装hexo 1npm install hexo -g Hexo初始化项目 123hexo init boke(生成的博客文件夹的名字，自定义,会在对应执行该语句的路径生成对应的文件)cd bokenpm install 执行完上面的命令 生成以下文件12345678node_modules：是依赖包public：存放的是生成的页面scaffolds：命令生成文章等的模板source：用命令创建的各种文章themes：主题_config.yml：整个博客的配置db.json：source解析所得到的package.json：项目所需模块项目的配置信息 安装github的管理工具 1234deploy:type: gitrepo: https://gitee.com/eastside/blog.gitbranch: master 每次上传新的博客内容，先要清理本地的缓存文件 1hexo clean 执行生成上传命令 1hexo g -d 上传需要安装 1npm install hexo-deployer-git --save 编写新的md文件代表新的博客 1hexo new 文件名 本地预览和同时发布到远程的浏览结果不一致 1这是由缓存造成的,需要先hexo clean,再hexo g -d部署到远程 HEXO语法转义规则 1234567891011121314151617181920212223! &amp;#33; — 惊叹号 Exclamation mark” &amp;#34; &amp;quot; 双引号 Quotation mark# &amp;#35; — 数字标志 Number sign$ &amp;#36; — 美元标志 Dollar sign% &amp;#37; — 百分号 Percent sign&amp; &amp;#38; &amp;amp; Ampersand‘ &amp;#39; — 单引号 Apostrophe( &amp;#40; — 小括号左边部分 Left parenthesis) &amp;#41; — 小括号右边部分 Right parenthesis* &amp;#42; — 星号 Asterisk+ &amp;#43; — 加号 Plus sign&lt; &amp;#60; &amp;lt; 小于号 Less than= &amp;#61; — 等于符号 Equals sign- &amp;#45; &amp;minus; — 减号&gt; &amp;#62; &amp;gt; 大于号 Greater than? &amp;#63; — 问号 Question mark@ &amp;#64; — Commercial at[ &amp;#91; --- 中括号左边部分 Left square bracket\ &amp;#92; --- 反斜杠 Reverse solidus (backslash)] &amp;#93; — 中括号右边部分 Right square bracket&#123; &amp;#123; — 大括号左边部分 Left curly brace| &amp;#124; — 竖线Vertical bar&#125; &amp;#125; — 大括号右边部分 Right curly brace]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
